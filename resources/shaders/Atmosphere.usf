#include "/Engine/Private/Common.ush"

#define CM_TO_SKY_UNIT 0.00001f

struct FSampleData
{
	float3 PlanetPos;
	float PlanetRadius;
	float AtmosphereThickness;
	fixed SampleCount;
	fixed SampleCountLight;
	float Scale;

	float3 LightDir;
	float3 LightIntensity;
};

struct FMedium
{
	float ScaleHeightR;
	float ScaleHeightM;
	
	//Rayleigh
	float3 ScatteringR;
	float3 AbsorptionR;
	float3 ExtinctionR;

	//Mie
	float3 ScatteringM;
	float3 AbsorptionM;
	float3 ExtinctionM;

	void InitCoefficients(const float3 ScatteringRay)
	{
		ScatteringR = ScatteringRay;
		AbsorptionR = 0;
		ExtinctionR = ScatteringR + AbsorptionR;
		//
		// ScatteringM = ScatteringMie;
		// AbsorptionM = AbsorptionMie;
		// ExtinctionM = ScatteringM + AbsorptionM;
	}
};

struct FAtmosphere
{
	FSampleData Sample;
	FMedium Medium;

	// Theta - angle between light direction and view direction
	float PhaseRayleigh(const float CosTheta)
	{
		return (3.0f / (16.0f * PI)) * (1.0f + CosTheta * CosTheta);
	}

	float3 Render(const float3 WorldPos, const float3 PlanetPos,
		const float PlanetRadius, const float AtmosphereThickness,
		const fixed SampleCount, const fixed SampleCountLight,
		const float ScaleHeightRay, const float3 ScatteringRay,
		const float UnitScale = 1.0f)
	{
		Sample.Scale = UnitScale;

		Sample.PlanetPos = PlanetPos;
		Sample.PlanetRadius = PlanetRadius;
		Sample.AtmosphereThickness = AtmosphereThickness;
		Sample.SampleCount = SampleCount;
		Sample.SampleCountLight = SampleCountLight;

		Sample.LightDir = ResolvedView.AtmosphereLightDirection[0].xyz;
		Sample.LightIntensity = ResolvedView.AtmosphereLightIlluminanceOuterSpace[0].rgb;

		Medium.ScaleHeightR = ScaleHeightRay;
		Medium.InitCoefficients(ScatteringRay);
		
		return SingleScattering(WorldPos, LWCToFloat(ResolvedView.WorldCameraOrigin));
	}

	float3 SingleScattering(const float3 WorldPos, float3 ViewPos)
	{
		const float3 ViewDir = normalize(WorldPos - ViewPos);
		
		ViewPos = (ViewPos - Sample.PlanetPos) * CM_TO_SKY_UNIT * Sample.Scale;

		const float4 Atmosphere = float4(0, 0, 0, Sample.PlanetRadius + Sample.AtmosphereThickness);
		
		float2 P = RayIntersectSphere(ViewPos, ViewDir, Atmosphere);
		if(P.x < 0 && P.y < 0)
			return 0;

		float2 PPlanet = RayIntersectSphere(ViewPos, ViewDir, float4(0, 0, 0, Sample.PlanetRadius));
		if(PPlanet.x > 0)
			P.y = PPlanet.x;
		
		P.x = max(P.x, 0.0f);
		P.y = min(P.y, 9000000.0f);

		//Accumulated light
		float3 A = 0;
		
		float OpticalDepth = 0;
		float CurrentSample = P.x;
		// Sample size
		const float Ds = (P.y - P.x) / float(Sample.SampleCount);

		for(int i = 0; i < Sample.SampleCount; i++)
		{
			//Sample point X
			const float3 X = ViewPos + ViewDir * (CurrentSample + Ds * 0.5);

			//Height/Altitude
			const float H = length(X) - Sample.PlanetRadius;

			const float DensityX = exp(-H / Medium.ScaleHeightR) * Ds;
			OpticalDepth += DensityX;

			//Light transmittance
			float2 PLight = RayIntersectSphere(X, Sample.LightDir, Atmosphere);
			
			float CurrentSampleLight = 0;
			float OpticalDepthLight = 0;

			const float DsLight = PLight.y / float(Sample.SampleCountLight);

			bool Underground = false;
			
			for(int j = 0; j < Sample.SampleCountLight; j++)
			{
				//ToDo: Unify float4. Light dir negated here?
				const float3 XLight = X + Sample.LightDir * (CurrentSampleLight + DsLight * 0.5);
				const float HLight = length(XLight) - Sample.PlanetRadius;
				if(HLight < 0)
				{
					Underground = true;
					break;
				}
				
				const float DensityLight = exp(-HLight / Medium.ScaleHeightR) * DsLight;

				OpticalDepthLight += DensityLight;
				CurrentSampleLight += DsLight;
			}
			//============ Light

			if(!Underground)
			{
				const float3 Transmittance = exp(-Medium.ExtinctionR * (OpticalDepth + OpticalDepthLight));
				A += Transmittance * DensityX;
			}
			
			CurrentSample += Ds;
		}

		const float CosTheta = dot(Sample.LightDir, ViewDir);
		const float PhaseR = PhaseRayleigh(CosTheta);
		float3 L = Sample.LightIntensity * (PhaseR * Medium.ScatteringR * A);
		
		return L;
	}
	
};

FAtmosphere Atmosphere;
